// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Linq;
using JetBrains.Annotations;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.EntityFrameworkCore.Utilities;

namespace Microsoft.EntityFrameworkCore.Scaffolding
{
    /// <summary>
    ///     Produces runtime directive xml from reflection objects
    /// </summary>
    public class DirectiveGenerator
    {
        private static readonly XNamespace ns = "http://schemas.microsoft.com/netfx/2013/01/metadata";
        private static readonly XAttribute DynamicRequiredAll = new XAttribute("Dynamic", "Required All");
        private static readonly XAttribute DynamicRequired = new XAttribute("Dynamic", "Required");
        private static readonly XComment AutogenComment = new XComment(CommandsStrings.AutogeneratedDirectivesFiles);
        private State _state;

        private class State
        {
            public readonly Dictionary<string, XElement> TypeDirectiveCache = new Dictionary<string, XElement>();
            public readonly HashSet<string> MethodInstantiationCache = new HashSet<string>();
        }

        private static string Serialize(Type type)
            => Serialize(type.GetTypeInfo());

        private static string Serialize(TypeInfo typeInfo)
        {
            var sb = new StringBuilder((typeInfo.FullName ?? typeInfo.Name).Split('`')[0].Replace('+', '.'));

            var typeArgs = typeInfo.ContainsGenericParameters
                ? typeInfo.GenericTypeParameters
                : typeInfo.GenericTypeArguments;

            if (typeArgs.Any())
            {
                sb.Append("{")
                    .Append(SerializeTypeArgs(typeArgs))
                    .Append("}");
            }

            return sb.ToString();
        }

        private static string SerializeTypeArgs(Type[] typeArgs)
            => string.Join(", ", typeArgs.Select(Serialize));

        private static XElement CreateMethodInstantiationDirective(MethodInfo methodInfo)
            => new XElement(ns + "MethodInstantiation",
                new XAttribute("Name", methodInfo.Name.Split('`')[0]),
                new XAttribute("Arguments", SerializeTypeArgs(methodInfo.GetGenericArguments())),
                DynamicRequired
                );

        private static XElement CreateTypeInstantiationDirective(TypeInfo typeInfo)
            => new XElement(ns + "TypeInstantiation",
                new XAttribute("Name", Serialize(typeInfo).Split('{')[0]),
                new XAttribute("Arguments", string.Join(", ", typeInfo.GenericTypeArguments.Select(Serialize))),
                DynamicRequiredAll);

        private static XElement CreateTypeDirective(TypeInfo typeInfo)
            => new XElement(ns + "Type",
                new XAttribute("Name", Serialize(typeInfo)),
                DynamicRequiredAll);

        public virtual string GenerateXml([NotNull] ICollection<MemberInfo> members)
        {
            Check.NotNull(members, nameof(members));

            _state = new State();

            var document = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
            document.Add(AutogenComment);

            var root = new XElement(ns + "Directives", new XAttribute("xmlns", ns));
            document.Add(root);

            foreach (var member in members.OrderBy(m => m.Name))
            {
                var typeInfo = member as TypeInfo;
                if (typeInfo != null)
                {
                    GetOrAddType(typeInfo);
                    continue;
                }

                var methodInfo = member as MethodInfo;
                if (methodInfo != null)
                {
                    GetOrAddGenericMethod(methodInfo);
                }
            }

            var library = new XElement(ns + "Library");
            root.Add(library);

            library.Add(_state.TypeDirectiveCache.Values.OrderBy(e => e.FirstAttribute.Value));

            return document.ToString();
        }

        private void GetOrAddGenericMethod(MethodInfo methodInfo)
        {
            var declaringType = methodInfo.DeclaringType.GetTypeInfo();
            var typeElement = GetOrAddType(declaringType);
            var methodElement = CreateMethodInstantiationDirective(methodInfo);

            var key = declaringType.FullName + ":" + methodElement;
            if (_state.MethodInstantiationCache.Contains(key))
            {
                return;
            }

            typeElement.Add(methodElement);
            _state.MethodInstantiationCache.Add(key);
        }

        private XElement GetOrAddType(TypeInfo typeInfo)
        {
            XElement directive;
            var key = typeInfo.FullName;
            if (!_state.TypeDirectiveCache.TryGetValue(key, out directive))
            {
                if ((typeInfo.GenericTypeArguments.Length > 0)
                    && !typeInfo.ContainsGenericParameters)
                {
                    directive = CreateTypeInstantiationDirective(typeInfo);
                }
                else
                {
                    directive = CreateTypeDirective(typeInfo);
                }

                _state.TypeDirectiveCache.Add(key, directive);
            }

            return directive;
        }
    }
}
